{"name":"Profiny","tagline":"Lightweight C++ Profiler","body":"## Dependencies ##\r\n\r\nStarting with v0.2, Profiny does not require any external library other than STL. For older versions of Profiny, you should install these libraries:\r\n\r\n* boost version 1.52 (or newer)\r\n\r\nYou can download compressed archives of releases here: [DOWNLOADS](http://cppip.blogspot.com/2013/05/profiny-downloads.html).\r\n\r\n---\r\n\r\n\r\n## Usage ##\r\n\r\nA sample code using Profiny can be written as follows:\r\n```\r\n\t#include \"Profiny.h\"\r\n\r\n\tint f(int n) {\r\n\t\tPROFINY_SCOPE\r\n\t\tint result = 1;\r\n\t\tfor (int i=1; i<n; i++) result *= i;\r\n\t\treturn result;\r\n\t}\r\n\r\n\tint g(int n) {\r\n\t\tPROFINY_SCOPE\r\n\t\tif (n < 2) return 1;\r\n\t\treturn g(n-1) * n;\r\n\t}\r\n\r\n\tint h2(int n);\r\n\r\n\tint h1(int n) {\r\n\t\tPROFINY_SCOPE\r\n\t\tif (n < 2) return 1;\r\n\t\treturn h2(n-1) * n;\r\n\t}\r\n\r\n\tint h2(int n) {\r\n\t\tPROFINY_SCOPE\r\n\t\tif (n < 2)\r\n\t\t\treturn 1;\r\n\t\treturn h1(n-1) * n;\r\n\t}\r\n\r\n\tint main() {\r\n\t\tPROFINY_SCOPE\r\n\t\tf(1000000000);\r\n\t\tg(9);\r\n\t\th1(9);\r\n\t\treturn 0;\r\n\t}\r\n```\r\nAs you see in the example, every function block starts with PROFINY\\_SCOPE. This is a Profiny macro, which means that, these blocks are registered to be profiled by Profiny. Any scope can be registered to Profiny (does not have to be function block). Also, you can profile starting from one point (not the beginning) of the scope till the end of it. Each scope can have at most one Profiny macro, otherwise the code won't compile.\r\n\r\n\r\n\r\n---\r\n\r\n\r\n## Compile ##\r\n\r\nWhile compiling the code, the user should select which profiling strategy to use by using -D argument of the compiler. Either PROFINY\\_CALL\\_GRAPH\\_PROFILER or PROFINY\\_FLAT\\_PROFILER should be defined, and Profiny will act according to these definitions as follows:\r\n\r\n1. if only PROFINY\\_CALL\\_GRAPH\\_PROFILER is defined, it will work as a call-graph profiler\r\n\r\n1. if only PROFINY\\_FLAT\\_PROFILER is defined, it will work as a flat profiler\r\n\r\n1. if neither of them is defined, Profiny macros will be set to blank (i.e. profiling will be off)\r\n\r\n1. if both of them are defined, it will give an error and won't compile\r\n\r\nSo the above code (main.cpp) can be compiled by either (if you are using an old version, you may also need to add these flags: `-lboost_timer -lboost_chrono -lboost_system`)\r\n```\r\n\tg++ -DPROFINY_CALL_GRAPH_PROFILER -o \"profiny_call_graph_test\" \"../main.cpp\"\r\n```\r\nor\r\n```\r\n\tg++ -DPROFINY_FLAT_PROFILER -o \"profiny_flat_test\" \"../main.cpp\"\r\n```\r\nor, if you want to switch profiling off\r\n```\r\n\tg++ -o \"profiny_not_profiled_test\" \"../main.cpp\"\r\n```\r\n\r\n\r\n---\r\n\r\n\r\n## Output ##\r\n\r\nBy default (if the profiling is not off), and if your program exits normally, Profiny will print profiling results in \"profinity.out\" file. Also, the user can force printing results at any time by calling:\r\n```\r\n\tprofiny::Profiler::printStats(\"filename\")\r\n```\r\n\r\nThe results of the above example will be as follows:\r\n\r\nIf flat profiling requested:\r\n```\r\n\t\t../main.cpp:f:8  T:2.58832  #:1  %:99.2922\r\n\t\t../main.cpp:g:19  T:0.0172229  #:1  %:174.186\r\n\t\t../main.cpp:h1:29  T:0.0164029  #:1  %:60.9647\r\n\t\t../main.cpp:h2:37  T:0.0163981  #:1  %:60.9828\r\n\t\t../main.cpp:main:45  T:2.62199  #:1  %:99.5425\r\n```\r\nIf call-graph profiling requested:\r\n```\r\n\t\t../main.cpp:main:45  T:2.62712  #:1  %:99.7289\r\n\t\t  ../main.cpp:f:8  T:2.59415  #:1  %:99.4546\r\n\t\t  ../main.cpp:g:19  T:0.0164109  #:1  %:182.805\r\n\t\t  ../main.cpp:h1:29  T:0.0165158  #:1  %:60.5482\r\n\t\t    ../main.cpp:h2:37  T:0.0165097  #:1  %:60.5705\r\n```\r\nIn the above results, each line represents a profile. Second column in each line shows total time, third one shows total number of executions for that scope, and the last column shows the CPU usage. As shown in the examples, CPU usage may be invalid if we have a really fast function (i.e. user and system times cannot be evaluated that precisely).\r\n\r\nIn call-graph profiling, the indentation shows the call graph. So, the same scope can be shown by multiple entries (i.e. if function \"f\" is called from \"g\" and \"h\", both calls will be shown separately). Note that this is not the complete call graph, instead, it is a call graph of scopes that we registered to Profiny.\r\n\r\n\r\n\r\n---\r\n\r\n\r\n## Advanced ##\r\n\r\nIn the profiling results, first column represents the name of the profiled scope. In this example we used PROFINY\\_SCOPE that's why the name simply is\r\n```\r\n\t<file>:<func>:<line>\r\n```\r\nIt is also possible to use these macros:\r\n\r\n**PROFINY\\_SCOPE**: This is the simplest macro. The profile name for this macro is as follows:\r\n```\r\n\t\t\t<file>:<func>:<line>\r\n```\r\n\r\n**PROFINY\\_SCOPE\\_WITH\\_ID(ID)**: This macro can be used where we want to differentiate profiles of a single scope by giving an ID to each. For example, we can use this macro if we want to profile every instance of a class separately. If we have a unique \"m\\_name\" member in the class, we can simply write:\r\n```\r\n\t\t\tPROFINY_SCOPE_WITH_ID(m_name)\r\n```\r\nto the beginning of each function, and profile methods of the instances (not the class' method). The name of each profile will be:\r\n```\r\n\t\t\t<file>:<func>:<line>:<ID>\r\n```\r\n**PROFINY\\_NAMED\\_SCOPE(NAME)**: This macro does not automatically generate profile name, instead, it takes it from the user. So, the profile name is as follows:\r\n```\r\n\t\t\t<NAME>\r\n```\r\n**PROFINY\\_NAMED\\_SCOPE\\_WITH\\_ID(NAME, ID)**: This macro uses name and ID given as arguments and constructs profile name as follows:\r\n```\r\n\t\t\t<NAME>:<ID>\r\n```\r\nLater, if you chose PROFINY\\_CALL\\_GRAPH\\_PROFILER, you may want to determine whether recursive calls will be omitted or not (omitted by default) by calling:\r\n```\r\n\tprofiny::Profiler::setOmitRecursiveCalls(bool)\r\n```\r\nIf call-graph profiling requested and recursive calls are not omitted the results will be\r\nas follows (including recursive calls):\r\n```\r\n\t../main.cpp:main:45  T:2.58801  #:1  %:99.3041\r\n\t  ../main.cpp:f:8  T:2.58789  #:1  %:99.3086\r\n\t  ../main.cpp:g:19  T:4.4433e-05  #:1  %:0\r\n\t    RECURSIVE@../main.cpp:g:19  T:2.9165e-05  #:1  %:0\r\n\t      RECURSIVE@../main.cpp:g:19  T:2.5138e-05  #:1  %:0\r\n\t  ../main.cpp:h1:29  T:3.0788e-05  #:1  %:0\r\n\t    ../main.cpp:h2:37  T:2.7134e-05  #:1  %:0\r\n\t      RECURSIVE@../main.cpp:h1:29  T:2.3411e-05  #:1  %:0\r\n\t        RECURSIVE@../main.cpp:h2:37  T:1.9694e-05  #:1  %:0\r\n\t          RECURSIVE@../main.cpp:h1:29  T:1.6154e-05  #:1  %:0\r\n\t            RECURSIVE@../main.cpp:h2:37  T:1.2546e-05  #:1  %:0\r\n```\r\nHappy profiling!\r\n","google":"UA-37850017-1","note":"Don't delete this file! It's used internally to help with page regeneration."}